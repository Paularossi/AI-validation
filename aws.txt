# aws instance: https://eu-west-3.console.aws.amazon.com/ec2/home?region=eu-west-3#Instances:instanceId=i-0dfc723863151aaa4
# key-pair: AIValid.pem
# ssh -i "AIValid.pem" ec2-user@ec2-51-44-183-211.eu-west-3.compute.amazonaws.com

curl "http://ec2-51-44-183-211.eu-west-3.compute.amazonaws.com:5000/getImages?workerId=TEST123"

# inside git bash
ssh -i "Desktop\phd\ad libraries and brands\AI-validation\AIValid.pem" ec2-user@ec2-51-44-183-211.eu-west-3.compute.amazonaws.com

# run postgresql
sudo systemctl status postgresql

[ec2-user@ip-172-31-14-50 ~]$ sudo service postgresql initdb
Hint: the preferred way to do this is now "/usr/bin/postgresql-setup --initdb --unit postgresql"
 * Initializing database in '/var/lib/pgsql/data'
 * Initialized, logs are in /var/lib/pgsql/initdb_postgresql.log

[ec2-user@ip-172-31-14-50 ~]$ sudo service postgresql start
Redirecting to /bin/systemctl start postgresql.service

[ec2-user@ip-172-31-14-50 ~]$ sudo -u postgres psql
could not change directory to "/home/ec2-user": Permission denied
psql (15.9)
Type "help" for help.

postgres=# CREATE DATABASE qualtricsimages;
CREATE DATABASE
postgres=# CREATE USER paularossi WITH PASSWORD 'paularossi99';
CREATE ROLE
postgres=# GRANT ALL PRIVILEGES ON DATABASE qualtricsimages TO paularossi;
GRANT
postgres=# \l
                                                 List of databases
      Name       |  Owner   | Encoding | Collate |  Ctype  | ICU Locale | Locale Provider |    Access privileges
-----------------+----------+----------+---------+---------+------------+-----------------+-------------------------
 postgres        | postgres | UTF8     | C.UTF-8 | C.UTF-8 |            | libc            |
 qualtricsimages | postgres | UTF8     | C.UTF-8 | C.UTF-8 |            | libc            | =Tc/postgres           +
                 |          |          |         |         |            |                 | postgres=CTc/postgres  +
                 |          |          |         |         |            |                 | paularossi=CTc/postgres
 template0       | postgres | UTF8     | C.UTF-8 | C.UTF-8 |            | libc            | =c/postgres            +
                 |          |          |         |         |            |                 | postgres=CTc/postgres
 template1       | postgres | UTF8     | C.UTF-8 | C.UTF-8 |            | libc            | =c/postgres            +
                 |          |          |         |         |            |                 | postgres=CTc/postgres
(4 rows)

# exit
postgres=# \q

# reconnect to the database:
psql -U paularossi -d qualtricsimages -h localhost

# restart postgresql
sudo systemctl restart postgresql

GRANT CREATE ON SCHEMA public TO paularossi;
ALTER DATABASE qualtricsimages OWNER TO paularossi;


-- Table for images
CREATE TABLE images (
    image_id TEXT PRIMARY KEY,
    image_url TEXT NOT NULL,
    image_text TEXT NOT NULL,
    image_brand TEXT NOT NULL,
    current_count INT DEFAULT 0,
    max_count INT NOT NULL
);

-- Table for assignments: which worker_id has seen which image
CREATE TABLE assignments (
    worker_id TEXT NOT NULL,
    image_id TEXT NOT NULL REFERENCES images(image_id),
    PRIMARY KEY (worker_id, image_id)
);

# check the database schema
qualtricsimages(> \dt
             List of relations
 Schema |    Name     | Type  |   Owner
--------+-------------+-------+------------
 public | assignments | table | paularossi
 public | images      | table | paularossi
(2 rows)

# chmod 400 "Desktop\AIValid.pem"
# upload images to the ec2 instance:

P70090005@SBENB1180 MINGW64 ~
$ scp -v -i "Desktop\AIValid.pem" "Desktop\images.csv" ec2-user@ec2-51-44-183-211.eu-west-3.compute.amazonaws.com:./

[ec2-user@ip-172-31-14-50 ~]$ ls
images.csv

# copy the images into the tables
\copy images (image_id, image_url, image_text, image_brand, max_count) FROM '/home/ec2-user/images.csv' CSV HEADER;

============= add here example of the first row 


# create an app.py file:
=========================================

from flask import Flask, request, jsonify
import psycopg2
import random

app = Flask(__name__)

def get_db_connection():
    conn = psycopg2.connect(
        dbname='qualtricsimages',
        user='paularossi',
        password='paularossi99',
        host='localhost'
    )
    return conn

@app.route('/getImages', methods=['GET'])
def get_images():
    worker_id = request.args.get('workerId')
    if not worker_id:
        return jsonify({"error": "workerId is required"}), 400
    
    conn = get_db_connection()
    cur = conn.cursor()

    # find images not shown to this worker and not exceeded max_count
    cur.execute("""
    SELECT image_id, image_url, image_text, image_brand
    FROM images
    WHERE current_count < max_count
      AND image_id NOT IN (
          SELECT image_id FROM assignments WHERE worker_id = %s
      );
    """, (worker_id,))
    candidates = cur.fetchall()

    if len(candidates) < 5:
        # not enough images left
        # how do I handle this scenario?
        return jsonify({"error": "Not enough images available"}), 200

    # randomly select 5 images
    chosen = random.sample(candidates, 5)

    # return them as JSON
    images = []
    for (img_id, img_url, img_text, img_brand) in chosen:
        images.append({"image_id": img_id, "image_url": img_url, "image_text": img_text, "image_brand": img_brand})

    cur.close()
    conn.close()

    return jsonify({"images": images})

@app.route('/increment', methods=['POST'])
def increment():
    data = request.get_json()  # data = {"payload": "{\"workerId\":\"...\"}"}
    
    worker_id = data.get('workerId')
    image_ids = data.get('imageIds')

    if not worker_id or not image_ids:
        return jsonify({"error": "workerId and imageIds are required"}), 400

    conn = get_db_connection()
    cur = conn.cursor()

    # increment the count for each image shown
    # or change to do it for each image separately? (after each block in qualtrics)
    for img_id in image_ids:
        cur.execute("
                    UPDATE images 
                    SET current_count = current_count + 1 
                    WHERE image_id = %s;
                ", (img_id,))
        cur.execute("
                    INSERT INTO assignments (worker_id, image_id) 
                    VALUES (%s, %s) 
                    ON CONFLICT DO NOTHING;
                ", (worker_id, img_id))

    conn.commit()
    cur.close()
    conn.close()

    return jsonify({"status": "success"})

=============================

# to change the code:
[ec2-user@ip-172-31-14-50 ~]$ nano app.py

ctrl+o to save and ctrl+x to exit

# to run it:
[ec2-user@ip-172-31-14-50 ~]$ python3 app.py
# works if opening another git bash and calling the curl command
# try testing it locally inside the ec2 instance:

curl "http://127.0.0.1:5000/getImages?workerId=TEST123"

# inside the Web Service on qualtrics:
http://ec2-51-44-183-211.eu-west-3.compute.amazonaws.com:5000/getImages?workerId=${e://Field/workerId}

# run the Flask app on port 5000 (or any other port) and reverse-proxy requests from port 80 or 443 via Nginx
# inside the instance:
sudo yum install -y nginx
sudo systemctl start nginx
[ec2-user@ip-172-31-14-50 ~]$ sudo systemctl enable nginx
Created symlink /etc/systemd/system/multi-user.target.wants/nginx.service â†’ /usr/lib/systemd/system/nginx.service.


# verify if Nginx is active:
sudo systemctl status nginx # should see something like active (running).

# create a dedicated config file under /etc/nginx/conf.d/. 
sudo nano /etc/nginx/conf.d/flask.conf

# now inside the file, add a server block:
server {
    listen 80;
    server_name ec2-51-44-183-211.eu-west-3.compute.amazonaws.com;

    location / {
        proxy_pass http://127.0.0.1:5000;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
        proxy_set_header Host $host;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
}

# run Gunicorn in the background with nohup

[ec2-user@ip-172-31-14-50 ~]$ gunicorn --bind 127.0.0.1:5000 app:app
[2025-01-01 11:30:11 +0000] [743587] [INFO] Starting gunicorn 23.0.0
[2025-01-01 11:30:11 +0000] [743587] [INFO] Listening at: http://127.0.0.1:5000 (743587)
[2025-01-01 11:30:11 +0000] [743587] [INFO] Using worker: sync
[2025-01-01 11:30:11 +0000] [743588] [INFO] Booting worker with pid: 743588

Ctrl+C to stop

# check if it's running and find the Process ID (PID):
[ec2-user@ip-172-31-14-50 ~]$ ps -ef | grep gunicorn
ec2-user  743655  716431  0 11:31 pts/0    00:00:00 /usr/bin/python3 /home/ec2-user/.local/bin/gunicorn --bind 127.0.0.1:5000 app:app
ec2-user  743656  743655  0 11:31 pts/0    00:00:00 /usr/bin/python3 /home/ec2-user/.local/bin/gunicorn --bind 127.0.0.1:5000 app:app
ec2-user  743796  716431  0 11:35 pts/0    00:00:00 grep --color=auto gunicorn

# this is how I manually stop it if I need to add new code

##### RELOAD GUNICORN WHEN UPDATING THE CODE INSIDE APP.PY
# reload the gunicorn
ps -ef | grep gunicorn
743656 (parent) PID # the 1

# kill the process and rebind it
kill 743655
nohup gunicorn --bind 127.0.0.1:5000 app:app &

# to check the logs from the Flask app for the Web Service updates:
[ec2-user@ip-172-31-14-50 ~]$ tail -f nohup.out



# to do:
- add more Post blocks after each image
- look at MTurk link (to include workerID)
================ REMEMEBER: reset the counts of images on AWS before running the survey


### STEPS TO CHECK THE DATABASE

ssh -i "Desktop\phd\ad libraries and brands\AI-validation\AIValid.pem" ec2-user@ec2-51-44-183-211.eu-west-3.compute.amazonaws.com
psql -U paularossi -d qualtricsimages -h localhost

# now do any query


### ================== add french/dutch/english tables
-- Table for french ads
CREATE TABLE images_en (
    image_id TEXT PRIMARY KEY,
    image_url TEXT NOT NULL,
    image_text TEXT NOT NULL,
    image_brand TEXT NOT NULL,
    current_count INT DEFAULT 0,
    max_count INT NOT NULL
);

CREATE TABLE assignments_en (
    worker_id TEXT NOT NULL,
    image_id TEXT NOT NULL REFERENCES images_en(image_id),
    PRIMARY KEY (worker_id, image_id)
);

exit

# load the new files
scp -v -i "Desktop\AIValid.pem" "Desktop\images_en.csv" ec2-user@ec2-51-44-183-211.eu-west-3.compute.amazonaws.com:./

# copy the contents of the files into the new tables (inside postgresql)
\copy images_en (image_id, image_url, image_text, image_brand, max_count) FROM '/home/ec2-user/images_en.csv' CSV HEADER;

# update the code inside app.py for the new tables
# EXAMPLE FOR ENGLISH

# same for English
@app.route('/getImagesEN', methods=['GET'])
def get_images_en():
    worker_id = request.args.get('workerId')
    if not worker_id:
        return jsonify({"error": "workerId is required"}), 400

    conn = get_db_connection()
    cur = conn.cursor()

    # get available images from images_en
    cur.execute("""
        SELECT image_id, image_url, image_text, image_brand
        FROM images_en
        WHERE current_count < max_count
          AND image_id NOT IN (
              SELECT image_id FROM assignments_en
              WHERE worker_id = %s
          );
    """, (worker_id,))
    candidates = cur.fetchall()

    if len(candidates) < 5:
        return jsonify({"error": "Not enough images available"}), 200

    chosen = random.sample(candidates, 5)

    images = []
    for (img_id, img_url, img_text, img_brand) in chosen:
        images.append({"image_id": img_id, "image_url": img_url, "image_text": img_text, "image_brand": img_brand})

    cur.close()
    conn.close()

    return jsonify({"images": images})

@app.route('/incrementEN', methods=['POST'])
def increment_en():
    data = request.get_json()
    worker_id = data.get('workerId')
    image_ids = data.get('imageIds')

    if not worker_id or not image_ids:
        return jsonify({"error": "workerId and imageIds are required"}), 400

    conn = get_db_connection()
    cur = conn.cursor()

    for img_id in image_ids:
        cur.execute("UPDATE images_en SET current_count = current_count + 1 WHERE image_id = %s", (img_id,))
        cur.execute("INSERT INTO assignments_en (worker_id, image_id) VALUES (%s, %s) ON CONFLICT DO NOTHING", (worker_id, img_id))

    conn.commit()
    cur.close()
    conn.close()

    return jsonify({"status": "success"})
